
	Play chipmunk physics engine

[ ]	How to access the *space*? It's very easy. We need to export the Balls() object in the 
	example named ball.html that comes with the chipmunk package. So Balls in jeforth is 
	the demo.js object and Balls.space is the chipmunk space. Everything is in this space.

[x]	The root members of the Balls() world:
	Balls obj>keys . cr 
	space,remainder,fps,mouse,simulationTime,drawTime,canvas2point,point2canvas,
	mouseBody,canvas,ctx,width,height,scale,update,drawInfo,draw,run,benchmark,
	stop,step,addFloor,addWalls
	
[x]	Things are all in Balls.space
	> Balls :> space obj>keys .
	stamp,curr_dt,bodies,rousedBodies,sleepingComponents,staticShapes,activeShapes,
	arbiters,contactBuffersHead,cachedArbiters,constraints,locked,collisionHandlers,
	defaultHandler,postStepCallbacks,iterations,gravity,damping,idleSpeedThreshold,
	sleepTimeThreshold,collisionSlop,collisionBias,collisionPersistence,enableContactGraph,
	staticBody,collideShapes,getCurrentTimeStep,setIterations,isLocked,addCollisionHandler,
	removeCollisionHandler,setDefaultCollisionHandler,lookupHandler,addShape,addStaticShape,
	addBody,addConstraint,filterArbiters,removeShape,removeStaticShape,removeBody,
	removeConstraint,containsShape,containsBody,containsConstraint,uncacheArbiter,eachBody,
	eachShape,eachConstraint,reindexStatic,reindexShape,reindexShapesForBody,useSpatialHash,
	activateBody,deactivateBody,processComponents,activateShapesTouchingShape,pointQuery,
	pointQueryFirst,nearestPointQuery,nearestPointQueryNearest,segmentQuery,segmentQueryFirst,
	bbQuery,shapeQuery,addPostStepCallback,runPostStepCallbacks,lock,unlock,makeCollideShapes,
	arbiterSetFilter,step OK 

[x] space.gravity is an object	
	> Balls :> space.gravity tib.
	Balls :> space.gravity \ ==> [object Object] (object)
	> Balls :> space.gravity obj>keys .
	x,y,add,sub,neg,mult,project,rotate OK 
	> Balls :> space.gravity (see)
	{
		"x": 0,
		"y": -500
	} OK 
	> Balls :> space.gravity.x tib.
	Balls :> space.gravity.x \ ==> 0 (number) <-- horizantal gravity
	> Balls :> space.gravity.y tib.
	Balls :> space.gravity.y \ ==> -500 (number) <-- virtical gravity. Negative is downward.
	> Balls :> space.gravity.y=0
	> Balls :> space.gravity.y tib.
	Balls :> space.gravity.y \ ==> 0 (number) <-- Dynamic change works !! he he he 

[x] Play with Balls.f body

	\ all bodies
	> Balls :> space.bodies obj>keys .
	0,1,2,3,4,5,6,7,8,9,10 OK ( when they are not in sleep )
	0=rock, 1~10=ball, the ramp is not in the body array !! <-- No, the ramp is a shape rather than a body
	> Balls :> space.bodies[0] tib.
	Balls :> space.bodies[0] \ ==> [object Object] (object)
	
	\ The array space.bodies are usually empty!! Because they are sleeping and 
	\ thus are not in space.bodies.
	> Balls :> space.bodies tib.
	Balls :> space.bodies \ ==>  (array)
	> Balls :> space.bodies.length . \ => 0 OK 
	> Balls :> space.bodies (see) \ ==> [] OK 
	> Balls :> space.gravity tib.
	 
	\ body object
	> Balls :> space.bodies[0] obj>keys .
	p,vy,vx,f,w,t,v_limit,w_limit,v_biasy,v_biasx,w_bias,space,shapeList,arbiterList,constraintList,
	nodeRoot,nodeNext,nodeIdleTime,m,m_inv,i,i_inv,rot,a,sanityCheck,getPos,getVel,getAngVel,
	isSleeping,isStatic,isRogue,setMass,setMoment,addShape,removeShape,removeConstraint,setPos,setVel,
	setAngVel,setAngleInternal,setAngle,velocity_func,position_func,resetForces,applyForce,applyImpulse,
	getVelAtPoint,getVelAtWorldPoint,getVelAtLocalPoint,eachShape,eachConstraint,eachArbiter,local2World,
	world2Local,kineticEnergy,activate,activateStatic,pushArbiter,sleep,sleepWithGroup OK 

	\ Position of a body
	> Balls :> space.bodies[0].getPos() tib.
	Balls :> space.bodies[0].getPos() \ ==> [object Object] (object)
	> Balls :> space.bodies[0].getPos() obj>keys .
	x,y,add,sub,neg,mult,project,rotate OK 

	\ Set position of a body
	Balls :> space.bodies[0].setPos(v(500,100))
	
	
	> Balls :> space.bodies tib.
	Balls :> space.bodies \ ==>  (array)
	> Balls :> space.sleepingComponents tib.
	Balls :> space.sleepingComponents \ ==> [object Object],[object Object],[object Object],[object Object] (array)
	
	\ Yes, this works. The body really got moved to the position and activated for a while.
		> Balls :> space.sleepingComponents[0].setPos(v(100,400)) 

	\ bodies.length 經常都是 0 因為都睡著了，跑進了 Balls :> space.sleepingComponents array
	\ 裡去了。
		> Balls :> space.bodies.length . \ ==> 0 OK 
	\ 實驗觀察, 證實只有醒著的 body 才會出現在 bodies array 裡
		> run> 20 for Balls :> space.bodies.length . space 1000 nap next \ 邊執行邊擾動物品
		0 0 0 0 0 0 8 3 2 9 8 6 8 8 11 11 9 9 8 10  OK 

	\ 遍覽所有 body 的方法
	> Balls :> space.eachBody .  
	function (func)
	{
		this.lock(); {
			var bodies = this.bodies;
			
			for(var i=0; i<bodies.length; i++){
				func(bodies[i]);
			}
			
			var components = this.sleepingComponents;
			for(var i=0; i<components.length; i++){
				var root = components[i];
				
				var body = root;
				while(body){
					var next = body.nodeNext;
					func(body);
					body = next;
				}
			}
		} this.unlock(true);
	} OK 

	> Balls :> space.eachBody(function(b){type(b.name+';')})
		ball#3;rock;ball#2;ball#10;ball#9;ball#8;ball#7;ball#4;ball#5;ball#6;ball#1; OK 
		
	\ 以上遍覽所有的 body 發現他們的順序不一定。
	\ 要不要保存每個 body 是 chipmunk user 的自由, chipmunk 本身管理所有 body 是分散在
	\ space.bodies 以及 space.sleepingComponents 結構裡面。 
	\ space.activateBody(body) 就是把 body 放進 space.bodies[] 裡去。

	[x] The below code brings all bodies into an jeforth array 'bodies'
		\ The array
			[] constant bodies // ( -- array ) \ Array of all bodies in the space
		\ Pack the array
			Balls :> space.eachBody(function(b){vm.g.bodies.push(b)})
		\ Print the entire array
			bodies <js> for(var i in tos()) type(i + " : " + tos()[i].name + "\n"); </js> drop

[x] How to rotate a body
	\ Method 1, Set angular velocity directly
		> bodies :: [1].setAngVel(3) \ anti-clock
		> bodies :: [5].setAngVel(-3) \ clock-wise
	\ Method 2, Set torque ( rotating force ) 轉矩, 轉動力 
		> bodies :> [5].t . \ ==> 0 keep the Angular Velocity constant
		> bodies :: [5].t=900 \ add rotating force to the body makes it rotate faster and faster
		> bodies :: [5].t=0 \ stop the torque force, AngVel become constant
		> bodies :: [5].t=-100 \ Turn to clock-wise
		> bodies :> [5].t . \ ==> -100 OK 
		> bodies :: [5].t=-300 \ faster
		> bodies :: [5].t=0 \ Keep the rotating speed
	[ ] body.i is not body.t, when body.t is set 0 body.t is another number
	
[x]	What is body.rot ? It's a vector
	> bodies :> [5].rot (see)
	{
		"x": 0.9970688464448313,
		"y": -0.07650957749964037
	} OK

[x] How to hide or disable the Demo drawInfo?
	--> Add one line to demo.js 
		Demo.prototype.drawInfo = function() {
		if(arguments.callee.hide) return; // H.C. Chen add a switch to turn it off
		... snip ...
	[x]	to disable the annoying information on the canvas.
		js: Demo.prototype.drawInfo.hide=true 
		
[x] float.f 裡,讓 chocolate[0] 轉動
	> run: 100 for choc :: [0].setAngle(0.5) 500 nap choc :: [0].setAngle(0) 500 nap next

[x] How to supress the rotation when draging a thing?
	/// Maximum rotational rate (in radians/second) allowed when updating the angular velocity.
	w_limit seems to be the answer	--> Yes! 0=no angular velocity, default is Infinity
	--> This value is good enough --> choc :: [0].w_limit=1.5
	body.w is the 角速度 Anglular Velocity
	
[x] To get a body's mass 
	--> choc :> [0].m tib.		

	To change the mass of a body
	--> choc :: [n].setMass(m) \ where n is a chocolate, m is its new mass.
	
	To list all chocolates' mass
	--> 
		cr choc <js>
			var choc = pop();
			for(var i=0; i<12; i++){
				type("Chocolate #" + i + " mass " + choc[i].m + "\n");
			}
		</js>
		
	To change all chocolates' mass
	--> 
		cr choc <js>
			var mm = 0.6;
			var choc = pop();
			for(var i=0; i<12; i++){
				choc[i].setMass(mm);
			}
		</js>

[x]	To see the defected chocolate
	--> choc :: [0].activate()  

[x]	To see a chocolate's position
	--> choc :> [0].p (see)
		{
			"x": 115.13832984959171,
			"y": 305.46889876462234
		} OK
		
	To set a chocolate's position
	--> choc :: [0].p=cp.v(x,y) choc :: [0].activate()
	
	To reset all chocolates to the lower left corner of the space
	--> 
		choc <js>
			var choc = pop();
			for(var i=0; i<12; i++){
				choc[i].p=cp.v(40,40);
				choc[i].activate();
			}
		</js>
		
[x]	To change the water level
	--> water :: bb_t=210 \ was 240
	
[x]	To understand a body, read cp.js 
	var Body = cp.Body = function(m, i) { ... }
	m	is mass, .setMass(n)
	i	is moment of inertia 轉動慣量 (or simply moment) of the body, setMoment()
	A body needs only (m,i) for both speed and rotation.
	While its shape is another thing. Moment or (i, inertia) is a function of shape 
	but not speed.
		cp.momentForCircle(mass,圓心0,半徑,offsetVector)
		cp.momentForSegment,
		cp.momentForPoly,
		cp.momentForBox,
		cp.momentForBox2,
[x] To understand a shape, read cp.js
	var Shape = cp.Shape = function(body) { ... }

[x] water :: setSensor(true) \ enable the water, become ice if disabled

> water :> verts .
140,100,140,240,630,240,630,100 OK 
> water :: setVerts({140,100,140,150,630,150,630,100})
JavaScript error : Unexpected token ,
 OK 
> water :: setVerts(({140,100,140,150,630,150,630,100}))
JavaScript error : Unexpected token ,
 OK 
> water :: setVerts([140,100,140,150,630,150,630,100])
JavaScript error : Cannot read property 'x' of undefined
 OK 
> water :: setVerts([140,100,140,150,630,150,630,100],{x:0,y:0})
 OK 
> water :> verts .
140,100,140,150,630,150,630,100 OK 

er run> 100 for random 12 * int 2 .r cr next \ --> 0~11 random
er run> 100 for random  2 * int 2 .r cr next \ --> 0~1  random


\ 萬一 海綿摔出去了, 把它移回來
sponge :> setPos({x:200,y:200})

[ ] 拉動某物時的慣性, 可能是 body.i body.i_inv, modify through body.setMoment()
	> choc :> [0].setMoment .
	function (moment)
	{
		assert(moment > 0, "Moment of Inertia must be positive and non-zero.");

		this.activate();
		this.i = moment;
		this.i_inv = 1/moment;
	} OK 
	> choc :> [0].i .
	47.24999999999999 OK 
	> choc :> [0].i_inv .
	0.021164021164021166 OK 


\ Get sponge's center position	
	> sponge :> getPos() (see)
	{
		"x": 389.3945442663677,
		"y": 400
	} OK 
	
\ The sponge's parameters	
	> sponge :> mass . \ ==>	1.323 OK 
	> sponge :> height . \ ==>	70 OK 
	> sponge :> width . \ ==>	450 OK 

\ Put a Choc on the sponge at the center
	{} sponge :> getPos() ( o p )
	js: tos(1).x=tos().x;tos(1).y=pop().y+vm.g.choc_size*8
	choc :: [0].setAngle(0)
	choc :: [0].setPos(pop()) \ set the choc's center above the sponge's left edge

\ Put a Choc on the sponge at the left edge
	{} sponge :> getPos() ( o p )
	js: tos(1).x=tos().x-vm.g.sponge.width/2+vm.g.choc_size/2;tos(1).y=pop().y+vm.g.choc_size*8
	choc :: [1].setAngle(0)
	choc :: [1].setPos(pop()) \ set the choc's center above the sponge's center

\ Put a Choc on the sponge at the right edge
	{} sponge :> getPos() ( o p )
	js: tos(1).x=tos().x+vm.g.sponge.width/2-vm.g.choc_size/2;tos(1).y=pop().y+vm.g.choc_size*8
	choc :: [2].setAngle(0)
	choc :: [2].setPos(pop()) \ set the choc's center above the sponge's right edge

: drop-choc-left ( i -- ) \ Drop choc[i] on the left edge of the sponge
	{} sponge :> getPos() ( i o p )
	js: tos(1).x=tos().x-vm.g.sponge.width/2+vm.g.choc_size/2
	js: tos(1).y=pop().y+vm.g.choc_size*5 ( i o )
	choc :: [tos(1)].setAngle(0)
	choc :: [pop(1)].setPos(pop()) ;
	
: drop-choc-right ( i -- ) \ Drop choc[i] on the right edge of the sponge
	{} sponge :> getPos() ( i o p )
	js: tos(1).x=tos().x+vm.g.sponge.width/2-vm.g.choc_size/2;
	js: tos(1).y=pop().y+vm.g.choc_size*5 ( i o )
	choc :: [tos(1)].setAngle(0)
	choc :: [pop(1)].setPos(pop()) ;

: 6:6 ( 8 numbers -- ) \ Put 6 chocs on each side
	6 for drop-choc-right drop-choc-left 500 nap next ;

: 5:5 ( 8 numbers -- ) \ Put 5 chocs on each side
	5 for drop-choc-right drop-choc-left 500 nap next ;

: 4:4 ( 8 numbers -- ) \ Put 4 chocs on each side
	4 for drop-choc-right drop-choc-left 500 nap next ;

: 3:3 ( 6 numbers -- ) \ Put 3 chocs on each side
	3 for drop-choc-right drop-choc-left 500 nap next ;

: 2:2 ( 4 numbers -- ) \ Put 2 chocs on each side
	2 for drop-choc-right drop-choc-left 500 nap next ;

: 1:1 ( 2 numbers -- ) \ Put 1 choc on each side
	drop-choc-right drop-choc-left ;

\ 挑出某一 chocolate 
	choc :: [4].setPos({x:500,y:400})

[x] float.f 裡,讓 chocolate[0] 轉動
	> run: 100 for choc :: [0].setAngle(0.5) 500 nap choc :: [0].setAngle(0) 500 nap next
	choc :: [0].setVel({x:0,y:200}) \ Jump the choc
	choc :: [0].setAngVel(0.5) \ Rotate the choc

[x] 12choc.f, home command needs to restore the sponge's position at the center of the 
	bucket. I have 'water' already. Water's verts and bb is almost the same thing. So
	the center position of the sponge is [bb.l+(bb.r - bb.l)/2, bb.b+(bb.t-bb.b)/2]
	
[x] The 4:4 command and friends has to freeze and unfreeze the water during putting on
	the Chocs or longer the pause time between each drop. Or a better idea is to temporarily 
	make the water to have a bigger mass to avoid big waves. If this is not doable then 
	change the angular velocity limit of the sponge is also a solutioin.
	--> The last idea works fine! Tested by the one-liner:
	    10 [for] replay 5000 nap 0 1 2 3 4 5 6 7 4:4 3000 nap [next]
[ ] improve 4:4 and friends, let 0 1 2 3 at left top down as well as the right side ones
	1 2 3 4 2:2 will be 
	> 1 2
	> 3 4
	0 2 1 3 2:2 will be 
	> 0 2 
	> 1 3
	So, swap 2,3 is the solution for 2:2
	1 2 3 4 5 6 3:3 will be
	> 1 2
	> 3 4
	> 5 6
	1 4 2 5 3 6 3:3 will be
    > 1 4 
	> 2 5
	> 3 6
	_ _ _ _ _ _ 
	0 3 1 4 2 5
	0 : 0
	1 : L/2 = 3
	2 : 上上一個 + 1 = 1
	3 : 上上一個 + 1 = 4
	4 : 上上一個 + 1 = 2
	5 : 上上一個 + 1 = 5
	
	[i]
	[L/2]
	[i
	