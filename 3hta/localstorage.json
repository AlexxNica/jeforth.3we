{"autoexec":"{\"doc\":\"<comment>\\n\\njs: outputbox.style.fontSize=\\\"1.5em\\\"\\njs: inputbox.style.fontSize=\\\"1.5em\\\"\\n\\njs> vm.appname char jeforth.3hta = [if] [else]\\n    .( Launch the briefing ) cr\\n    <o> <iframe name=\\\"An introduction to jeforth.3ce\\\" width=\\\"96%\\\" height=\\\"1000\\\" align=\\\"center\\\" src=\\\"http://note.youdao.com/share/?id=79f8bd1b7d0a6174ff52e700dbadd1b2&amp;type=note\\\" frameBorder=\\\"1\\\" marginWidth=\\\"1\\\" marginHeight=\\\"1\\\" scrolling=\\\"Yes\\\"> </iframe></o> drop\\n    cr cr \\n[then]\\n\\ncls\\n.( Execute the 'list' command that lists all local storage fields ) cr\\nlist\\n\\n\\n</comment>\",\"mode\":true,\"readonly\":false}","Play with numeric.js":"{\"doc\":\"\\ncls \\n\\\\ Linear algebra example. We start with a matrix.\\n<js>\\nvar A = [[1,2,3],\\n         [4,5,6],\\n         [7,3,9]]; A </jsV> value A\\n\\n\\\\ Let's also make a vector.\\n<js> var x = [3,1,2]; x </jsV> value x\\n\\n\\\\ Matrix-vector product.  b = A (.) x\\n<js> var b = numeric.dot(vm.g.A,vm.g.x); b </jsV> value b b (see)\\n\\n\\\\ Matrix inverse.  ~A \\n<js> var Ainv = numeric.inv(vm.g.A); Ainv </jsV> value Ainv \\nAinv (see)\\n\\n\\\\ Let's check it:   ~A (.) b = x Bingo!!!!\\n<js> numeric.dot(vm.g.Ainv,vm.g.b); </jsV> (see)\\n\\n\\\\ Determinant\\n<js> numeric.det(vm.g.A); </jsV> cr tib. \\n\\n\\\\ Sin wave\\n<js> var x = numeric.linspace(0,6.3,25); x </jsV> to x x (see)\\n\\n<js> var y = numeric.sin(vm.g.x); y </jsV> value y y (see)\\n\\n\\n\\n\\nstop\\njs> numeric tib.\\n\\nstop\\njs> vm.appname==\\\"jeforth.3hta\\\" [if] char js/numeric-1.2.6.js\\n[else] char http://www.numericjs.com/lib/numeric-1.2.6.js [then]\\nreadTextFile \\\\ 先讀取 .js 檔, 但不能直接用\\n<text> \\nwindow.numeric = numeric;  // 先對 source 做一點必要的加工, 把 numeric 掛上 global \\n</text> + </js> \\\\ 然後才執行\\t\\n\\nstop\\n\\\\ Also hosted on BootCDN.cn\\n\\\\ http://cdn.bootcss.com/numeric/1.2.6/numeric.js\\n\\n\\\\ These lines works fine! Test ok on 3ce, 3hta ADO reads only local files\\n\\\\ so the path should be only \\\"js/numeric-1.2.6.js\\\",\\n\\nchar     http://localhost:8888/js/numeric-1.2.6.js     readTextFile tib.\\nchar http://www.numericjs.com/lib/numeric-1.2.6.js     readTextFile tib.\\nchar http://www.numericjs.com/lib/numeric-1.2.6.min.js readTextFile tib.\\n\\n\\n\",\"mode\":true,\"readonly\":false}","Log 2016/05/30":"{\"doc\":\"[x] solar-system.f 簡化到這樣就會出問題：\\n    run: 1000 for js: h=vm.g.stars[0].x+=0.5 50 nap next er\\n    更簡化到: 50 nap or 50 sleep or 1 nap 但是要多試幾次也會捅出問題。\\n    --> naughty-balls2.f 執行中下 20 nap 也會出類似的問題。感覺是 nap 的 resume 回到錯誤的 TIB 了。\\n[x] [nap] interpret-only 與 nap compile-only 要繼續討論清楚 <---- forget it, nap/sleep \\n    good enough now.\\n[x] MetaMoji 上的討論 has given me a hint: when the event handler gets control, the \\n    system must be in idle state (True). That means tib should be empty or at the end\\n    (Also true).\\n\\n~ ~ 結 論 ~ ~\\n\\n*** 根本問題是 command line TSR resume 回來之後不能還指望使用自己留下的 stack/rstack.\\n    你 resume 回來必須面對一個不確定的 stack/rstack。也就是 nap/sleep resume 之後必須\\n    假設 stack/rstack 已經與 nap/sleep 之前面目全非了。\\n\\n    50 nap 就是一個最簡單的 command line TSR! 它會回到 idle 之後才結束工作。因為它目前是個 colon \\n    word 所以它還會在 rstack tos 留一個 0 這已經不好了！ --> 新的 nap 已經改成 code word 就不會\\n    在 rstack 留下一個 0 了。\\n\\n*** TIB is a global variable, save-restore tib in outer() 是為了實現 js: dictate() 所必須，\\n    每個 dictate() 都是獨立的 event. event handlers are using tib so they have to save-restore \\n    tib. 正因為 javascript 是 single thread 因此只要 nap/sleep 各自 save-restore tib/ntib \\n    每個 event handler 就可以 run 得很好。\\n    \\n*** TSR 上手的時間點, 亦即 nap 的 resume() timeout 上手時, 一定是別人已經讓出來了, javascript host\\n    已經在 idle 的狀態。也就是 tib==\\\"\\\", ntib==0. 設斷點觀察 test1, test2 已獲證實。寫成 command\\n    line 的 tib TSR 與寫成 word 的 loop 如 test1 test2 者都一樣有 tib 被 save-restore\\n    through nap/sleep 的 tibwas/ntibwas 只是 test1 test2 的 ntib 都已經到了底沒有\\n    作用了。因此 save-restore 這樣的 tib/ntib 然後透過 outer(ipwas) resme 之後\\n    不論是剩下的 inner loop 或剩下的 tib outer loop 都 resume 無誤。\\n\\n[x] I've got a way to check if the resume() event handler in nap/sleep is triggered\\n    in *the correct* situation, check the tib==undefined. Try try see . . . 錯了! 這\\n    時候的 tib 不是 undefined 而是根本錯了！ --> rstack unbalance was the root cause.\\n\\n[x] Root cause may be that [again] can't jump back to its [begin] when in tib loop\\n    after resuming from resume() of nap. Seems like the rtos that saves the [begin]\\n    ntib has gone, so [again] will actually restore an incorrect ntib !!!! So what \\n    removes the rtos what was supposed to be the return point of [begin] ?? 這也解釋了\\n    為何 cut ... rewind 的方式 ok, 因為 [again] rpop() 出來的是個 0 而不是 [begin] 之後的 \\n    ntib, cut 之後的 ntib 正好就是 0, 所以歪打正著。如果讓 [begin] 治標像 cut 一樣把用過的 \\n    tib 都切掉也應該會好。 <-- RI: rstack unbalance, 但 TSR 不該期望 resumt() 之後 stack/rstack\\n    必須 balance!! 那是人家的自由，這才是真正的 RI.\\n\\n    [x] 哈! [begin] 之後的 ntib 還好好地躺在 rstack 裡, 這竟然是個 rstack balance 出錯的問題!\\n        nap 剛上手的時候查 rstack tos 應該就是 555 正確的 return ntib, 然後 trace 下去...\\n        nap 剛上手的時候查 rstack was [555,0] where 555 is the return ntib, 0 is nap's\\n        RET address because it's run from command line.\\n        --> 出錯時的 nap resume() 會看到 [555,0,0] 多了一個 0 就是問題所在, 所以應該由 [again]\\n            restore ntib=555 處變成 restore ntib=0 留下了 555, 就是這樣出錯了。\\n        --> 多一個 0 @ rtos 是 50 nap 留下的, 這沒錯呀。 --> 看到了, 這時候有兩個 nap 在等\\n            setTimeout(), 接下來是哪個 nap 先 timeout 照理說是都可以，然而因為 [begin][again]\\n            有用到 rstack 所以 50 nap 留在 rstack 裡的 0 就可能會被 solar-system.f 的 nap \\n            拿去當作 [again] 的回跳 ntib 而出了問題。\\n        --> nap 把控制權交出去時理當 stack 與 rstack 都保持不變, 不能讓別人看到 context\\n            有任何改變, 而 stack, rstack 就是重要的 context。同理, tib ntib ip 也是 context \\n            所以 nap resume 前後要 save-restore. 但是 save-restore 對 rstack 不適合(吧?)。\\n    [x] 就 save-restore rstack 吧!? 不行, 萬一幫別人 save 的 rstack 內容理應湮滅卻被 restore \\n        還是問題。\\n    [x] 那就是仿照 cut .. rewind 改寫 [begin]..[again], [begin].. flag [until] 嘍!\\n        避免用到 rstack . . . 不對, 要 supported nested 就不能沿用 cut-rewind 的簡略方法。\\n    [x] [begin] [again] [begin] [until] [for][next] 不能用 rstack 存放 jump back ntib.\\n        有 javascript 當靠山, 直接用 local variable 就好了, 哪需要用到 rstack?! \\n        --> 不是 compiled code 辦不到!!\\n    [X] 只好用 tib 本身來放 jump back ntib 了, 這時候的 TIB 是個 CONSTANT 不會變動了, 因此它的尾巴可\\n        以任意加長，拿來添加 jump back ntib 正好有 stack 的效果。要記得，我們有 support nested flow\\n        structure. ==> Bingo! 終極方向, 正確。\\n\\n[x] 先寫好 tib.push tib.pop tib.tos 直接放 tib 尾巴, charCodeAt() String.fromCharCode()\\n\\ncode tib.push ( int -- ) \\\\ Push the integer to end of TIB as a comment\\n    tib += \\\"\\\\n\\\\\\\\ \\\" + String.fromCharCode(pop());\\n    end-code \\n\\ncode tib.tos ( -- int ) \\\\ Get integer from end of the TIB \\n    var value = tib.charCodeAt(tib.length-1);\\n    push(value); \\n    end-code \\n\\n: tib.pop ( -- int ) \\\\ Pop integer from end of the TIB \\n    tib.tos ( int ) js: tib=tib.slice(0,-4) ;\\n[x] 改寫 [begin][again][until] ==> Big success! 一次成功。\\n    solar-system.f naughty-balls2.f 的問題都直接解掉了。因為 nap, [begin][again] 都不期望\\n    rstack 靜止了。 \\n    [x] 繼續用這三個新 words: tib.push tib.tos tib.pop 改寫 [for][next] --> 一次成功\\n\\n    *** 根本問題是 command line TSR resume 回來之後不能還指望使用自己留下的 stack/rstack。\\n        你 resume 回來必須面對一個不確定的 stack/rstack。也就是 nap/sleep resume 之後必須\\n        假設 stack/rstack 已經與 nap/sleep 之前面目全非了。\\n\\n        50 nap 就是一個最簡單的 command line TSR! 它會回到 idle 之後才結束工作。因為它目前是個 colon \\n        word 所以它還會在 rstack tos 留一個 0 這已經不合格了！ \\n        [x] 改成 code word 看看 --> naughty-balls2.f 跑起來, 然後下 50 nap 不會出問題了。因為雖然\\n            naughty-balls2.f 的 [begin][again] loop 有留下 jump back address in rstack 可能會\\n            傷到別的(之前的)TSR, 但 50 nap 本身既不留足跡也不看 stack/rstack 因此它可以平安結束，且\\n            不會傷到別的 TSR。\\n\\n[x] sleep 也要像 nap 一樣改寫成 code word 吧? 否則它既是 colon word 也會在 rstack 留下一個\\n    代表 RET 的 0 這表示 sleep 工作證長的條件是它 suspend 期間 rstack 不能被動到! 這個條件應\\n    該要避免。 ---> Done! ^2016-06-11 23:32:38\\n\\n[x] Debug  the moving sun of solar-system.f  2016-06-07 14:21:50\\n    The problem is: nap behaves unexpectedly sometimes.\\n\\n[x] 照以下這段 test program 執行, test2 不會被執行到, 只有 test1 不斷重複。\\n    已知原 solar-system.f 用 [begin][again] TSR 移動太陽失敗是不同問題。\\n\\n    : test1 begin 3456 dup . space nap again ;\\n    : test2 begin 1234 dup . space nap again ;\\n    test1 test2\\n\\n    3456 3456 3456 3456 3456 3456  \\\\ This is correct. nap is to wait I/O, all commands are running\\n    in ONE line of time, synchrunously in another word. That's why.\\n\\n    可是再一次手動執行 test2 之後就變成只見 1234. The previous task is still running. But . . .\\n    doing the test2 job <---- problem!  This problem has gone 似乎是 after nap changed to code word\\n    > test2\\n    1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 1234 \\n    > stop\\n\\n    [x] q1. 最初的 test2 到底有沒有執行到? <--- The answer is NO!\\n        : test1 .\\\" test1 \\\" begin  1000 dup . space nap again ;\\n        : test2 .\\\" test2 \\\" begin 10000 dup . space nap again ;\\n        test1 test2 ==> test1 3456  OK 3456 3456 3456 3456 3456 \\n        因為 nap , sleep 的設計就是要「接地」回到 interpreter idle 狀態去等 I/O, 因此不該緊接著執行之後的指令。\\n        這是對的。因為 test1 是無窮迴路, 所以 test2 根本執行不到, 這也沒錯。\\n\\n    [x] q2. 為何手動執行 test2 會干擾到 test1 的執行 <--- 好像 nap 改成 code word 就好了\\n        --> test2 會把 test1 的 tibwas, ntibwas, ipwas 都蓋掉, 所以 test1 的 setTimeout() 還在跑, 但是\\n            效果變成是另一個有點時間延遲的 test2。 這個現象即使改寫出另一個 nap2 (怕是因為 tibwas \\n            後一個蓋掉前一個) 給 test2 用也一樣！ 所以不是這個原因, 每個 nap 的 tibwas 都是獨立的。\\n\\n            So, it is not because of the SAME resume() function that was suspected incorrectedly \\n            the same instance, no it's fine. \\n            \\n            : test1 begin 3000 dup . space nap again ;\\n            : test2 begin 10000 dup . space nap2 again ;\\n            test1 test2\\n\\n        [x] 結果還是一樣！！ 原因跟 nap nap2 無關, 唯一的聯繫就是 TIB !! 因為 nap nap2 都 \\n            save restore tib/ntib 會不會因此 corrupted? --> 的確是 tib 出問題但它也是症狀,\\n            真正原因是 rstack corrupted.\\n\\n    [x] q3. What if command line instead of test1, test2 (they are as words)?\\n        [begin] 3456 dup . space nap [again]\\n        [begin] 1234 dup . space nap [again]\\n        --> They work fine as anticipated. So, only test1, test2 words are in trouble.\\n        --> 我懂了! 從 command line 下這些命令時, 是真的有 tib 輸入給 forth interpreter. As a word,\\n            like test1, test2 where tib become a shifting thing (啥? TIB沒問題的) then it's not \\n            tib/ntib to save-restore but only IP. <--- 後來 [nap] 只 save/restore ip 果然也可以但\\n            那不是正解, 只是避開 root cause 而已。\\n\\n    [x] 執行 test1 之後, 50 nap 會不會出問題？ --> No problem. 50 nap problem only happening in \\n        solar-system.f and naughty-balls2.f, strange! [x] root cause is rstack corrupted.\\n\\n    [x] 執行 test1 之後, 它的 tib 從 source code 看來, 好像就湮滅了。反之, 用 command line 的從結\\n        果看來 TIB 有被保存。 <---- 錯! 兩者的 tib 都保存在 nap/sleep 的 tibwas 裡好好的。\\n\\n    [/] Modify nap, try nap2. It save-restore ip if is in compiling state, tib/ntib if is in\\n        interpret state.\\n\\n        code [nap] ( mS -- ) \\\\ Suspend to idle, resume after mS. Multiple nap is allowed.\\n            var ipwas=ip, delay=pop();\\n            ip = 0; // ip = 0 reserve rstack, suspend the forth VM \\n            setTimeout(resume,delay);\\n            function resume(){outer(ipwas)}\\n            end-code compile-only \\n            /// for used in words  \\n\\n        : test1 begin 3000 dup . space [nap] again ;\\n        : test2 begin 10000 dup . space [nap] again ;\\n        test1 test2\\n    [x] 用 [nap] 則 test2 test1 同時可以跑, 且 stop 停不下來, 因為 begin-again 不是在 tib 裡面跑\\n        的, 所以 [nap] 算不算接地? [nap] 回到 idle 之後剩下的 tib 內容就會被拿去執行。但是原來的\\n        程式的確是停下來了, 因此 I/O delay 的效果還是有的。問題是 tib command line 隨後的 word 會\\n        在前一個 word 還在等 I/O 時就已經上手，這個特性用起來要非常小心。\\n    \\n\\n-----------------\\n\\n[x] 3nw 一出 error 就 jsc 一大堆。\\n    --> 3htm/f/jsc.f , 3nd/f/jsc.f 有兩個,結果依 3nw 的 path 優先順序抓到 3nd 的而應該用\\n        3thm 的才對。用完整 path include 即可。\\n\\n[x] 3ce F5 doesn't refresh <-- 這是 3ce 的關係, 有辦法嗎?\\n    既然 {F5} 隨 platform 各異即應定義前先檢查是否已經存在。\\n    --> 3ce 直接把 F5 擋掉算了 --> 也不好, 都已經針對 3ce 寫了何不解決問題。\\n    ==> runtime.reload, 這個不成功\\n        chrome.runtime.reload() Reloads the app or extension. \\n        --> 直接把 3ce ext page 關掉然後亂 load 一個網頁，不知所云。\\n        --> 這個 reload 似乎指的是整套 Chrome extension re-install。\\n    ==> tabs.reload, 這個成功了!! (for 3ce)\\n        chrome.tabs.reload(integer tabId, object reloadProperties, function callback) Reload a tab. \\n        active-tab :> id js: chrome.tabs.reload(pop()) \\n    ==> 3nw 也有同樣的問題, 解法如下：\\n        js: window.location.href=window.location or js: window.location.reload(true);\\n        --> 以上也對,但根本不是這個, RI: 是引進 local storage 之後 3nw 的 platform.f 要整個都在\\n            3hta/f/platform.f 之前, 當初放得很亂, 出了問題。\\n        ==> 好了, 連 Ctrl-Plus Ctrl-Minus 都修好了。 ^2016-06-02 11:42:11\\n\\n[x] 3ce, F2 in trouble, status reversed, 3hta too!!\\n    OK Input box EditMode = undefined <---- \\n    Input box EditMode = true <--- reversed\\n    [x] 3hta, 3nw, 3ce, 3htm verify. ^2016-06-01 09:05:08\\n\\n[x] tutor-cloth.f console3we strange. \\n    [x] Improve the scrollto position. \\n        was: window.scrollTo(0,endofinputbox.offsetTop)\\n        modifi only those quit.f should be enough. Or even easier, redefine\\n        the cr command would be enough! <-- not enough, also vm.forthConsoleHandler() too\\n        and it is redefined in 3hta\\\\f\\\\jquery.f. So, both cr and forthConsoleHandler() need\\n        to use the new function vm.scroll2inputbox() so modify it should work.\\n        \\\\ window.scrollTo(0,endofinputbox.offsetTop) chang to vm.scroll2inputbox()\\n            [x]3ce/target.f [x]3hta,[x]3htm,[x]3nw,[x]3ce/quit.f [x]all forthConsoleHandler() \\n            [x]ce.f [ ]3htm/platform.f\\n        \\\\ Define vm.scroll2inputbox\\n            [x]jeforth.3nw.html, [x]jeforth.3ce.js, [x]jeforth.hta [x]jeforth.3htm.js\\n        [x] 搞懂 scrollTo, see YNote : \\\"圖解 HTML 網頁上的東西 element 的位置與寬高值 ScrollTo, width, Top, Height\\\"\\n            1. Blur 避免 forthConsoleHandler() 的作用。它總是把畫面焦點 scroll 到 inputbox 但是只針對\\n               inputbox:focus 的時候。所以若要控制畫面焦點就必須 blur 出 inputbox 否則會被它拉回去。\\n            2. js> endofinputbox js> elePlayarea insertAfter 之後就好了。\\n                js> endofinputbox.offsetTop \\\\ ==> 3088 (number) 用 F12 debugger 實驗,徹底了解每個值。\\n                js> endofinputbox.clientTop \\\\ ==> 0 (number)\\n                js> endofinputbox.scrollTop \\\\ ==> 0 (number)\\n                js> endofinputbox.clientTop \\\\ ==> 0 (number)\\n     [x] quit.f 最後一行應該是 \\targs tib.insert 而非 js: vm.scroll2inputbox();inputbox.focus()\\n            否則 tutor-cloth.f 控制 scrollTo for 開始位置變成被最後一行蓋掉而無效。\\n            [x]3thm quit,[x]3ce quit,[]3nw quit, []3hta quit \\n     [x] Font size not consistant either. <--- 整理, 把所有東西都納入 class=essay 範圍即可。\\n     [x] 最後印出 tutor-cloth.f 的 snipet 需要改進。 <-- Ok now. ^2016-06-01 18:18:25\\n\\n\\n\",\"mode\":true,\"readonly\":false}","Log 2016-06-12 10:14:38":"{\"doc\":\"[ ] stop() 是個 DOM 的 native code!! \\n[ ] Youtube presentation of numeric.js\\n[ ] 準備 release master 新版, search \\\"kvm.minor_version\\\"\\n    全部加 200 代表 GitHub master release 的版號。\\n    [x] jeforth.3nd.js --> version 2 -> 202\\n    [x] jeforth.3nw.html, /package.json -> version 22 -> 222\\n    [x] jeforth.3htm.js --> to be version 2 now -> 202\\n    [x] jeforth.3ce.js(3ce extension pages)-> 202\\n    [x] jeforth.3ce, ce.f(Target page) -> 202\\n    [x] jeforth.3ce, background.js -> 202\\n    [x] jeforth.hta --> <HTA> tag. to be version 3 now -> 203 \\n    [ ] GitHub read me should feature the published 3ce Chrome extension.\\n    [ ] README.md 上的 demo 也要改寫好一點。最好能有浮動 console3we 框。\\n        --> 先把結構改好, link 出去的內容先弄成 under constructing. 日起有功,穩步推進。\\n\\n\",\"mode\":true,\"readonly\":false}"}